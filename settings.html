<div id="qvink_memory_settings" class="qvink_memory_settings_content">
  <div class="inline-drawer">
    <div class="inline-drawer-toggle inline-drawer-header">
      <div class="flex-container alignitemscenter margin0">
        <b id="qvink_title" title="Message Summarize">Qvink Memory</b>
        <i id="qvink_popout_button" title="Move config to floating popout" class="fa-solid fa-window-restore menu_button margin0"></i>
      </div>
      <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
    </div>

    <div class="inline-drawer-content">
      <div class="qvink_memory_settings_content">
        <hr>
        <div class="flex-container justifyspacebetween alignitemscenter">
          <button id="toggle_chat_memory" class="menu_button flex2"><span>Toggle Memory</span></button>
          <button id="refresh_memory" class="menu_button fa-solid fa-sync margin0" title="Force Update Now"></button>
        </div>

        <hr>
        <h4 class="textAlignCenter">Summarization Config</h4>

        <label class="checkbox_label">
          <input id="auto_summarize" type="checkbox" />
          <span>Auto Summarize</span>
        </label>

        <div class="flex-container justifyspacebetween alignitemscenter" style="margin-top:8px;">
          <label style="display:flex;align-items:center;" title="How many messages to wait before summarizing again (e.g. 20)">
            <span style="margin-right:.5em">Update Frequency</span>
            <input id="message_threshold" type="number" min="1" placeholder="20" style="width:7em" />
          </label>

          <label style="display:flex;align-items:center;" title="Maximum word count for the rolling summary">
            <span style="margin-right:.5em">Max Summary Words</span>
            <input id="max_summary_words" type="number" min="50" placeholder="350" style="width:7em" />
          </label>
        </div>

        <hr>
        <h4 class="textAlignCenter">Misc.</h4>

        <label class="checkbox_label">
          <input id="debug_mode" type="checkbox" />
          <span>Debug Mode</span>
        </label>

        <div style="display:flex;gap:.5rem;justify-content:flex-end;margin-top:8px;">
          <button id="revert_settings" class="menu_button">Revert</button>
          <button id="save_settings" class="menu_button">Save</button>
        </div>
        <hr>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  function safeById(id) { return document.getElementById(id); }

  // Elements (Updated IDs)
  const EL = {
    auto_summarize: safeById('auto_summarize'),
    message_threshold: safeById('message_threshold'),      // WAS: short_term_context_limit
    max_summary_words: safeById('max_summary_words'),      // WAS: long_term_context_limit
    debug_mode: safeById('debug_mode'),
    save_settings: safeById('save_settings'),
    revert_settings: safeById('revert_settings'),
    refresh_memory: safeById('refresh_memory'),
    toggle_chat_memory: safeById('toggle_chat_memory')
  };

  // Default UI values
  const UI_DEFAULTS = {
    auto_summarize: true,
    message_threshold: 20,
    max_summary_words: 350,
    debug_mode: false
  };

  // Populate UI from settings object
  function populateUI(settings = {}) {
    const s = Object.assign({}, UI_DEFAULTS, settings || {});
    if (EL.auto_summarize) EL.auto_summarize.checked = !!s.auto_summarize;
    if (EL.message_threshold) EL.message_threshold.value = s.message_threshold ?? 20;
    if (EL.max_summary_words) EL.max_summary_words.value = s.max_summary_words ?? 350;
    if (EL.debug_mode) EL.debug_mode.checked = !!s.debug_mode;
  }

  // Read UI values to settings object
  function readUI() {
    return {
      auto_summarize: !!(EL.auto_summarize && EL.auto_summarize.checked),
      message_threshold: parseInt(EL.message_threshold?.value || 20, 10),
      max_summary_words: parseInt(EL.max_summary_words?.value || 350, 10),
      debug_mode: !!(EL.debug_mode && EL.debug_mode.checked)
    };
  }

  // Wiring
  function wireToAPI(api) {
    api.getSettings().then(populateUI).catch(() => populateUI());

    if (EL.save_settings) {
      EL.save_settings.addEventListener('click', async () => {
        const s = readUI();
        await api.setSettings(s);
        if (s.debug_mode) console.log('[UI] Settings saved:', s);
      });
    }

    if (EL.revert_settings) {
      EL.revert_settings.addEventListener('click', async () => {
        const fresh = await api.getSettings().catch(() => null);
        populateUI(fresh || UI_DEFAULTS);
      });
    }

    // Live Listeners for smoother UX
    if (EL.message_threshold) {
        EL.message_threshold.addEventListener('change', async () => {
            await api.setSettings({ message_threshold: parseInt(EL.message_threshold.value) });
        });
    }

    if (EL.refresh_memory) {
      EL.refresh_memory.addEventListener('click', () => {
        if (typeof api.refreshMemory === 'function') api.refreshMemory();
      });
    }
  }

  // Poll for API
  let attempts = 0;
  const poll = setInterval(() => {
    attempts++;
    if (window.qvink_memory && typeof window.qvink_memory.getSettings === 'function') {
      clearInterval(poll);
      wireToAPI(window.qvink_memory);
      return;
    }
    if (attempts >= 50) {
      clearInterval(poll);
      populateUI(); // Fallback
    }
  }, 100);

  populateUI();
})();
</script>
